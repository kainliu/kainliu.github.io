<!-- home > archives > notes > about > posts (null)--><!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Solve Biggest K Problem By Heap, In Right Way | Westworld</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Asar|Imprima"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/images/blog-logo.png"><link rel="apple-touch-icon" href="/images/blog-logo.png"><link rel="apple-touch-icon-precomposed" href="/images/blog-logo.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div id="header"><div class="body_container"><div class="site-name"><h1 class="hidden">Solve Biggest K Problem By Heap, In Right Way</h1><a id="logo" href="/."><img src="/images/blog-logo.png" class="blog-logo nofancybox"><span>Westworld</span></a><p class="description"></p></div><div id="nav-menu"><a href="/"><i class="fa fa-rocket"> Home</i></a><a href="/archives/"><i class="fa fa-sitemap"> Archives</i></a><a href="/about/"><i class="fa fa-user-circle"> About</i></a></div></div></div><div id="layout" class="pure-g body_container"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><div class="post-header"><div class="screen-wide-bg"><div class="post-header-container"><i class="post-thumbnail"><img src="/images/cart.png" class="nofancybox"/></i><h1 class="post-title">Solve Biggest K Problem By Heap, In Right Way</h1><div class="post-desc">From brute force to vigilant power.</div><div class="post-meta"><span class="author">Kai</span><span class="date">2017-07-18</span></div></div></div></div><div class="post-content"><p>In previous blog <a href="/posts/complexity-of-python-operations/">Complexity of Python Operations</a>, I noticed that the way that Richard used to solve the biggest K problem by heap is arguable. </p>
<h3 id="Richard’s-statement"><a href="#Richard’s-statement" class="headerlink" title="Richard’s statement"></a>Richard’s statement</h3><p>He mentioned that, in order to</p>
<blockquote>
<p>use priority to find the 10 biggest (of N) values: we would enqueue N values and then dequeue 10 values.</p>
</blockquote>
<p>There are two methods to compare with,</p>
<ul>
<li>Implementation 1: Add each new value into an array (complexity = <code>O(1)</code>) for <code>N</code> times, and remove the highest priority value (complexity = <code>O(N)</code>) for <code>10</code> times. $$O(1) * N + O(N) * 10 = O(N)$$</li>
<li>Implementation 2: Add each new value into a heap (complexity = <code>O(logN)</code>) for <code>N</code> times, and remove the highest priority value (complexity = <code>O(logN)</code>) for <code>10</code> times. $$O(logN) * N + O(logN) * 10 = O(N logN)$$</li>
</ul>
<p>Therefore, the conclusion is,</p>
<blockquote>
<p>So, as N gets bigger, Implementation 1 will eventually become faster … for the “find the 10 biggest” task.</p>
</blockquote>
<h3 id="Questions"><a href="#Questions" class="headerlink" title="Questions"></a>Questions</h3><p>The most questionable part is: <strong>Is the cost of building a heap as high as <code>O(NlogN)</code> ?</strong></p>
<p>As we all know the time complexity of <code>heapsort</code> is also <code>O(NlogN)</code>, however, by heapsorting an array, all the elements are sorted. Then why should we perform an operation, that is close to <code>heapsort</code>, to find top $K$ elements?</p>
<p>It’s not necessary. The answer is No.</p>
<p>There are two ways two initialize a heap:</p>
<ol>
<li>Heapify the whole tree, everytime when one new value added.</li>
<li>Heapify the whole tree, after all values are added.</li>
</ol>
<p>Obviously the first option will cause no less operations than the second one. Such operation differences can be visualized in <a href="https://visualgo.net/en/heap" target="_blank" rel="noopener">Visualgo.net</a>.<br>Notice there are two options in left bottom menu:</p>
<ul>
<li>Create(A) - <code>O(N log N)</code></li>
<li>Create(A) - <code>O(N)</code></li>
</ul>
<p>The results after heapifying <code>[2,7,26,25,19,17,1,90,3,36]</code> are plotted as following trees,</p>
<p><img src="/images/heap-two-examples.png?width=50" alt="The two options generate different heaps, both of which satisfy the principle of heap. "></p>
<p>Different forms of heaps, and both legal. These example is another strong evidence for:</p>
<center> Heap is a partly-sorted structure. </center>

<p>These options reflect two corresponding ways, and it’s contrary to intuition that the second option has time complexity as low as $O(N)$. </p>
<center> Why is the cost of building a heap <code>O(N)</code> ? </center>



<h3 id="Explaination"><a href="#Explaination" class="headerlink" title="Explaination"></a>Explaination</h3><p>I will quote explaination from <a href="https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity" target="_blank" rel="noopener">Emre nevayeshirazi</a>,</p>
<p><img src="/images/heap-build-work.png?width=50" alt="Given a tree with height=3, the bottommost nodes require 0 swapping operation, and the topmost node requires 3 swapping operations in worst cases. "></p>
<blockquote>
<p>The main idea is that in the <code>build_heap</code> algorithm the actual heapify cost is not <code>O(log N)</code> for all elements.</p>
<p>When heapify is called, the running time depends on how far an element might move down in tree before the process terminates. In other words, it depends on the height of the element in the heap. In the worst case, the element might go down all the way to the leaf level.</p>
<p>Let us count the work done level by level.</p>
<p>At the bottommost level, there are $2^{h}$ nodes, but we do not call heapify on any of these, so the work is 0. At the 2nd level from the bottom are $2^{h − 1}$ nodes, and each might move down by 1 level. At the 3rd level from the bottom, there are $2^{h − 2}$ nodes, and each might move down by 2 levels.</p>
<p>As you can see not all heapify operations are <code>O(log N)</code>.</p>
</blockquote>
<p>Given a tree with $N$ nodes, the maximum height of a balanced tree, such as a heap tree, $H = Math.ceil(log N)$. In other words, </p>
<p>$$ N \le 2^{H+1} $$</p>
<p>Then, we sum up times of swapping operation, from 1 level above bottom, to the top most level. In $h$-th level, there are $2^{H-h}$ nodes to be handled. Thus, total complexity is</p>
<p>$$\sum_{h=1}^H h * 2^{H-h} = 2^H * \sum_{h=1}^H \frac{h}{2^{h}} \approx \frac{N}{2} * S$$<br>where we define,<br>$$ S = \sum_{h=1}^H \frac{h}{2^{h}} = \frac{1}{2} + \frac{2}{4} + \frac{3}{8} + … \frac{H}{2^H}$$</p>
<p>And $S$ has a limit, plotted as follows,<br><img src="/images/heap-limit.png" alt="Using R to visualize the limit of $S$."></p>
<p>$$ \lim_{x\to\infty} S = 2 $$</p>
<p>We can come to a conclusion that, </p>
<center>The time complexity of building a heap is <code>O(N)</code>.</center>

<h3 id="Back-to-finding-K-biggest"><a href="#Back-to-finding-K-biggest" class="headerlink" title="Back to finding K biggest"></a>Back to finding K biggest</h3><p>First, add each element into an array, which will cost <code>O(N)</code>.</p>
<p>Second, build a <strong>max heap</strong> from nodes in 1-level above bottom. Traverse over these nodes, with index less than half of the total amount, will cost <code>O(N)</code>.</p>
<p>Third, extract the top node, and re-heapify after each extraction, which will cost <code>O(logN * K)</code>.</p>
<p>In total, it costs $O(2 N + K logN)$ operations. </p>
<center>As N/K grows, heap enhanced implementation keeps a stable and low time complexity.</center>


<h4 id="Keep-a-heap-of-size-K"><a href="#Keep-a-heap-of-size-K" class="headerlink" title="Keep a heap of size K"></a>Keep a heap of size <code>K</code></h4><p>Another idea will be only to keep biggest K elements known so far, as a <strong>min heap</strong>. Every time when the new value is bigger than the smallest one in heap, we replace and re-heapify. This solution only requires one traversal of the array.</p>
<p>The overall complexity is $O(logK) * O(N) = O(N log K)$. This solution requires much smaller space but in exchange it will take longer time.</p>
<p>But still, heap enchanced solution outperforms the $O(NK)$ solution.</p>
<p>Heap rocks! Richard’s conclusion is not true, as an example for <em>sometimes there is not a “best all the time” implementation</em>, his statement is not accurate.</p>
</div><div class="post-meta"><div class="tags"><a href="/tags/algorithm/">algorithm</a><a href="/tags/heap/">heap</a><!-- tag.name--></div></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><div><a data-url="http://westworld.name/posts/solve-biggest-k-problem-by-heap-in-right-way/" data-id="cjkq38bya00085iqb84900jg0" class="article-share-link">Share</a></div><div id="disqus_show" class="readmore"><a class="show-comments" href="javascript:return false;"><span class="disqus-comment-count" data-disqus-identifier="posts/solve-biggest-k-problem-by-heap-in-right-way/"> Comments</span></a></div><div id="disqus_thread"></div><script>// Requires jQuery of course.
$(document).ready(function() {
    $('.show-comments').on('click', function(){
        var disqus_shortname = 'kaigithub';
        // ajax request to load the disqus javascript
        $.ajax({
                type: "GET",
                url: "//" + disqus_shortname + ".disqus.com/embed.js",
                dataType: "script",
                cache: true
        });
        // hide the button once comments load
        $(this).fadeOut();
    });
});
</script><script id="dsq-count-scr" src="//kaigithub.disqus.com/count.js" async></script><div id="post_nav_container" class="screen-wide-bg">  <div class="post-nav pure-u-1 pure-u-md-4-4"><div class="pure-u-md-1-2"><a href="javascript:return false;" class="pre no-more"><span>You are reading the lastest post</span><i><img src="/images/cart.png" class="nofancybox"></i></a></div><div class="pure-u-md-1-2"> <a href="/posts/thoughts-on-a-beautiful-trick-of-memorization-in-python/" class="next"><span>Thoughts on A Beautiful Trick for Memorization</span><i><img src="/images/target.png" class="nofancybox"></i></a></div></div></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer"><p>© <a href="/." rel="nofollow">Westworld.</a><span> Site Generated by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo. </a></span></p><p> <span> Theme modified from <a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo">Maupassant. </a></span><span>Icons from <a rel="nofollow" target="_blank" href="http://www.flaticon.com">Flaticon </a>are licensed by CC 3.0 BY.</span></p></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    preview: "none"
  }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></body></html>