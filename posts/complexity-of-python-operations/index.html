<!-- home > archives > notes > about > posts (null)--><!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Complexity of Python Operations | Westworld</title><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Asar|Imprima"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/images/blog-logo.png"><link rel="apple-touch-icon" href="/images/blog-logo.png"><link rel="apple-touch-icon-precomposed" href="/images/blog-logo.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div id="header"><div class="body_container"><div class="site-name"><h1 class="hidden">Complexity of Python Operations</h1><a id="logo" href="/."><img src="/images/blog-logo.png" class="blog-logo nofancybox"><span>Westworld</span></a><p class="description"></p></div><div id="nav-menu"><a href="/"><i class="fa fa-rocket"> Home</i></a><a href="/archives/"><i class="fa fa-sitemap"> Archives</i></a><a href="/about/"><i class="fa fa-user-circle"> About</i></a></div></div></div><div id="layout" class="pure-g body_container"><div class="pure-u-1 pure-u-md-4-4"><div class="content_container"><div class="post"><div class="post-header"><div class="screen-wide-bg"><div class="post-header-container"><i class="post-thumbnail"><img src="/images/justice-scale.png" class="nofancybox"/></i><h1 class="post-title">Complexity of Python Operations</h1><div class="post-desc">A clear and inspiring explanation by Richard Pattis.</div><div class="post-meta"><span class="author">Kai</span><span class="date">2017-05-21</span></div></div></div></div><div class="post-content"><p><img src="/images/big-o-1.png?width=60" alt="Big-O Complexity Chart. From &lt;i&gt;bigocheatsheet.com&lt;/i&gt;"></p>
<p>This article <a href="https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt" target="_blank" rel="noopener"><code>Complexity of Python Operations</code></a> has a clear and inspiring explanation of computation complexity.<br>I really like the way it analyses problems, especially the section for <a href="#Priority-Queue">Priority Queue</a>. I reformat the whole article to Markdown as follows.</p>
<hr>
<h3 id="Complexity-of-Python-Operations"><a href="#Complexity-of-Python-Operations" class="headerlink" title="Complexity of Python Operations"></a>Complexity of Python Operations</h3><p>Author: <a href="http://www.ics.uci.edu/~pattis/" target="_blank" rel="noopener">Richard E. Pattis</a><br><a href="https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt" target="_blank" rel="noopener">https://www.ics.uci.edu/~pattis/ICS-33/lectures/complexitypython.txt</a></p>
<hr>
<p>In this lecture we will learn the complexity classes of various operations on Python data types. Then we will learn how to combine these complexity classes to compute the complexity class of all the code in a function, and therefore the complexity class of the function. This is called “static” analysis, because we do not need to run any code to perform it (contrasted with Dynamic or Empirical Analysis, when we do run code and take measurements).</p>
<h2 id="Python-Complexity-Classes"><a href="#Python-Complexity-Classes" class="headerlink" title="Python Complexity Classes"></a>Python Complexity Classes</h2><p>In <a href="http://www.ics.uci.edu/~thornton/ics46/Notes/" target="_blank" rel="noopener">ICS-46</a> we will write low-level implementations of all of Python’s data types and see/understand WHY these complexity classes apply. For now we just need to try to absorb (not memorize) this information, with some -but minimal- justification.</p>
<p>Binding a value to any name (copying a reference) is <code>O(1)</code>. Simple operators on integers (whose values are small: e.g., under 12 digits) like <code>+</code> or <code>==</code> are also <code>O(1)</code>.</p>
<p>In all these examples, <code>N = len(data-type)</code>. The operations are organized by increasing complexity.</p>
<h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists:"></a>Lists:</h3><table>
<thead>
<tr>
<th>Operation</th>
<th>Example</th>
<th>Complexity Class</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Index</td>
<td>l[i]</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Store</td>
<td>l[i] = 0</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Length</td>
<td>len(l)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Append</td>
<td>l.append(5)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Pop</td>
<td>l.pop()</td>
<td>O(1)</td>
<td>same as l.pop(-1), popping at end</td>
</tr>
<tr>
<td>Clear</td>
<td>l.clear()</td>
<td>O(1)</td>
<td>similar to l = []</td>
</tr>
<tr>
<td>Slice</td>
<td>l[a:b]</td>
<td>O(b-a)</td>
<td>l[1:5] : O(1) <br> l[:] : O(len(l)-0)=O(N)</td>
</tr>
<tr>
<td>Extend</td>
<td>l.extend(…)</td>
<td>O(len(…))</td>
<td>depends only on len of extension</td>
</tr>
<tr>
<td>Construction</td>
<td>list(…)</td>
<td>O(len(…))</td>
<td>depends on length of …</td>
</tr>
<tr>
<td>check ==, !=</td>
<td>l1 == l2</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Insert</td>
<td>l[a:b] = …</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Delete</td>
<td>del l[i]</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Remove</td>
<td>l.remove(…)</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Containment</td>
<td>x in/not in l</td>
<td>O(N)</td>
<td>searches list</td>
</tr>
<tr>
<td>Copy</td>
<td>l.copy()</td>
<td>O(N)</td>
<td>Same as l[:] which is O(N)</td>
</tr>
<tr>
<td>Pop</td>
<td>l.pop(i)</td>
<td>O(N)</td>
<td>O(N-i) <br> l.pop(0):O(N) (see above <code>l.pop(-1):O(1)</code> )</td>
</tr>
<tr>
<td>Extreme value</td>
<td>min(l)/max(l)</td>
<td>O(N)</td>
<td>searches list</td>
</tr>
<tr>
<td>Reverse</td>
<td>l.reverse()</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Iteration</td>
<td>for v in l:</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Sort</td>
<td>l.sort()</td>
<td>O(N Log N)</td>
<td>key/reverse mostly doesn’t change</td>
</tr>
<tr>
<td>Multiply</td>
<td>k*l</td>
<td>O(k N)</td>
<td>5*l : O(N) <br> <span style="color:gray;"><font style="text-decoration: line-through;">len(l)*l : O(N^2)</font> (Kai’s comment: correct but confusing)</span></td>
</tr>
</tbody>
</table>
<p>Tuples support all operations that do not mutate the data structure (and with the same complexity classes).</p>
<h3 id="Sets"><a href="#Sets" class="headerlink" title="Sets:"></a>Sets:</h3><table>
<thead>
<tr>
<th>Operation</th>
<th>Example</th>
<th>Complexity Class</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Length</td>
<td>len(s)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Add</td>
<td>s.add(5)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Containment</td>
<td>x in/not in s</td>
<td>O(1)</td>
<td>compare to list/tuple - O(N)</td>
</tr>
<tr>
<td>Remove</td>
<td>s.remove(5)</td>
<td>O(1)</td>
<td>compare to list/tuple - O(N)</td>
</tr>
<tr>
<td>Discard</td>
<td>s.discard(5)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Pop</td>
<td>s.pop(i)</td>
<td>O(1)</td>
<td>compare to list - O(N)</td>
</tr>
<tr>
<td>Clear</td>
<td>s.clear()</td>
<td>O(1)</td>
<td>similar to s = set()</td>
</tr>
<tr>
<td>Construction</td>
<td>set(…)</td>
<td>O(len(…))</td>
<td>depends on length of …</td>
</tr>
<tr>
<td><code>==</code> , <code>!=</code></td>
<td>s != t</td>
<td>O(len(s))</td>
<td>same as len(t): False in O(1) if the lengths are different</td>
</tr>
<tr>
<td><code>&lt;=</code> , <code>&lt;</code></td>
<td>s &lt;= t</td>
<td>O(len(s))</td>
<td>issubset (s &lt;= t) == (t &gt;= s)</td>
</tr>
<tr>
<td><code>&gt;=</code> , <code>&gt;</code></td>
<td>s &gt;= t</td>
<td>O(len(t))</td>
<td>issuperset</td>
</tr>
<tr>
<td>Union</td>
<td>s</td>
<td>t</td>
<td>O(len(s)+len(t))</td>
<td></td>
</tr>
<tr>
<td>Intersection</td>
<td>s &amp; t</td>
<td>O(len(s)+len(t))</td>
<td></td>
</tr>
<tr>
<td>Difference</td>
<td>s - t</td>
<td>O(len(s)+len(t))</td>
<td></td>
</tr>
<tr>
<td>Symmetric Diff</td>
<td>s ^ t</td>
<td>O(len(s)+len(t))</td>
<td></td>
</tr>
<tr>
<td>Iteration</td>
<td>for v in s:</td>
<td>O(N)</td>
<td></td>
</tr>
<tr>
<td>Copy</td>
<td>s.copy()</td>
<td>O(N)</td>
</tr>
</tbody>
</table>
<p>Sets have many more operations that are <code>O(1)</code> compared with lists and tuples. Not needing to keep values in a specific order (which lists/tuples require) allows for faster operations.</p>
<p>Frozen sets support all operations that do not mutate the data structure (and with the same complexity classes).</p>
<h3 id="Dictionaries-dict-and-defaultdict"><a href="#Dictionaries-dict-and-defaultdict" class="headerlink" title="Dictionaries: dict and defaultdict"></a>Dictionaries: dict and defaultdict</h3><table>
<thead>
<tr>
<th>Operation</th>
<th>Example</th>
<th>Complexity Class</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td>Index</td>
<td>d[k]</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Store</td>
<td>d[k] = v</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Length</td>
<td>len(d)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Delete</td>
<td>del d[k]</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>get/setdefault</td>
<td>d.method</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Pop</td>
<td>d.pop(k)</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Pop item</td>
<td>d.popitem()</td>
<td>O(1)</td>
<td></td>
</tr>
<tr>
<td>Clear</td>
<td>d.clear()</td>
<td>O(1)</td>
<td>similar to s = {} or = dict()</td>
</tr>
<tr>
<td>View</td>
<td>d.keys()</td>
<td>O(1)</td>
<td>same for d.values()</td>
</tr>
<tr>
<td>Construction</td>
<td>dict(…)</td>
<td>O(len(…))</td>
<td>depends # (key,value) 2-tuples</td>
</tr>
<tr>
<td>Iteration</td>
<td>for k in d:</td>
<td>O(N)</td>
<td>all forms: keys, values, items</td>
</tr>
</tbody>
</table>
<p>So, most dict operations are <code>O(1)</code>.</p>
<p>defaultdicts support all operations that dicts support, with the same complexity classes (because it inherits all the operations); this assumes that calling the constructor when a values isn’t found in the defaultdict is <code>O(1)</code> - which is true for int(), list(), set(), … (the things we commonly use)</p>
<p>Note that <code>for i in range(...)</code> is <code>O(len(...))</code>; so <code>for i in range(1,10)</code> is <code>O(1)</code>.<br>If len(alist) is N, then<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(alist)):</span><br></pre></td></tr></table></figure></p>
<p>is O(N) because it loops N times. Of course even<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range (len(alist)//<span class="number">2</span>):</span><br></pre></td></tr></table></figure></p>
<p>is <code>O(N)</code> because it loops N/2 times, and dropping the constant 1/2 makes it <code>O(N)</code>: the work doubles when the list length doubles.</p>
<p>Finally, when comparing two lists for equality, the complexity class above shows as <code>O(N)</code>, but in reality we would need to multiply this complexity by <code>O(==)</code> where <code>O(==)</code> is the complexity class for checking whether two values in<br>the list are <code>==</code>. If they are ints, <code>O(==)</code> would be O(1); if they are strings, <code>O(==)</code> in the worst case it would be <code>O(len(string))</code>. This issue applies any time an <code>==</code> check is done. We mostly will assume <code>==</code> checking on values in lists is <code>O(1)</code>.</p>
<hr>
<h2 id="Composing-Complexity-Classes-Sequential-and-Nested-Statements"><a href="#Composing-Complexity-Classes-Sequential-and-Nested-Statements" class="headerlink" title="Composing Complexity Classes: Sequential and Nested Statements"></a>Composing Complexity Classes: Sequential and Nested Statements</h2><p>In this section we will learn how to combine complexity class information about simple operations into complexity information about complex operations (composed from simple operations). The goal is to be able to analyze all the statements in a function/method to determine the complexity class of executing the function/method.</p>
<hr>
<h3 id="Law-of-Addition-for-big-O-notation"><a href="#Law-of-Addition-for-big-O-notation" class="headerlink" title="Law of Addition for big-O notation"></a>Law of <code>Addition</code> for big-O notation</h3><p><code>O(f(n)) + O(g(n))</code> is <code>O( f(n) + g(n) )</code></p>
<p>That is, we when adding complexity classes we bring the two complexity classes inside the O(…). Ultimately, O( f(n) + g(n) ) results in the bigger of the two complexity class (because we drop the lower added term). So,</p>
<p><code>O(N) + O(Log N)  =  O(N + Log N)  =  O(N)</code></p>
<p>because N is the faster growing function.</p>
<p>This rule helps us understand how to compute the complexity of doing some SEQUENCE of operations: executing a statement that is <code>O(f(n))</code> followed by executing a statement that is <code>O(g(n))</code>. Executing both statements SEQUENTIALLY is <code>O(f(n)) + O(g(n))</code> which is <code>O( f(n) + g(n) )</code> by the rule above.</p>
<p>For example, if some function call f(…) is O(N) and another function call g(…) is O(N Log N), then doing the sequence</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(...)</span><br><span class="line">g(...)</span><br></pre></td></tr></table></figure>
<p>is O(N) + O(N Log N) = O(N + N Log N) = O(N Log N). Of course, executing the sequence (calling f twice)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f(...)</span><br><span class="line">f(...)</span><br></pre></td></tr></table></figure>
<p>is O(N) + O(N) which is O(N + N) which is O(2N) which is O(N).</p>
<p>Note that for an if statement like:</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test:        assume complexity of test    <span class="keyword">is</span> O(T)</span><br><span class="line">   block <span class="number">1</span>      assume complexity of block <span class="number">1</span> <span class="keyword">is</span> O(B1)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   block <span class="number">2</span>      assume complexity of block <span class="number">2</span> <span class="keyword">is</span> O(B2)</span><br></pre></td></tr></table></figure>
<p>The complexity class for the if is O(T) + max(O(B1),O(B2)). The test is always evaluated, and one of the blocks is always executed. In the worst case, the if will execute the block with the largest complexity. So, given</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> test:        complexity <span class="keyword">is</span> O(N)</span><br><span class="line">   block <span class="number">1</span>      complexity <span class="keyword">is</span> O(N^<span class="number">2</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">   block <span class="number">2</span>      complexity <span class="keyword">is</span> O(N)</span><br></pre></td></tr></table></figure>
<p>The complexity class for the if is O(N) + max (O($N^2$),O(N))) = O(N) + O($N^2$) = O($N^2$). If the test had complexity class O($N^3$), then the complexity class for the if is O($N^3$) + max (O($N^2$),O(N))) = O($N^3$).</p>
<hr>
<h3 id="Law-of-Multiplication-for-big-O-notation"><a href="#Law-of-Multiplication-for-big-O-notation" class="headerlink" title="Law of Multiplication for big-O notation"></a>Law of <code>Multiplication</code> for big-O notation</h3><p><code>O(f(n)) * O(g(n))</code> is <code>O( f(n) * g(n) )</code></p>
<p>If we repeat an O(f(N)) process O(N) times, the resulting complexity is O(N) * O(f(N)) = O( Nf(N) ). An example of this is, if some function call f(…) is O($N^2$), then executing that call N times (in the following loop)<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(N):</span><br><span class="line">    f(...)</span><br></pre></td></tr></table></figure></p>
<p>is O(N) * O($N^2$) = O($N*N^2$) = O($N^3$)</p>
<p>This rule helps us understand how to compute the complexity of doing some statement INSIDE A BLOCK controlled by a statement that is REPEATING it. We multiply the complexity class of the number of repetitions by the complexity class of the statement(s) being repeated.</p>
<p>Compound statements can be analyzed by composing the complexity classes of their constituent statements. For sequential statements the complexity classes are added; for statements repeated in a loop the complexity classes are multiplied.</p>
<hr>
<h3 id="An-example"><a href="#An-example" class="headerlink" title="An example"></a>An example</h3><p>Let’s use the data and tools discussed above to analyze (determine their complexity classes) three different functions that each compute the same result:</p>
<blockquote>
<p>Whether or not a list contains only unique values (no duplicates).</p>
</blockquote>
<p>We will assume in all three examples that <code>len(alist)</code> is N.</p>
<h4 id="Algorithm-1"><a href="#Algorithm-1" class="headerlink" title="Algorithm 1"></a>Algorithm 1</h4><blockquote>
<p>A list is unique if each value in the list does not occur in any later indexes: alist[i+1:] is a list containing all values after the one at index i.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique1</span> <span class="params">(alist)</span>:</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(alist)):  <span class="comment"># O(N)</span></span><br><span class="line">    <span class="keyword">if</span> alist[i] <span class="keyword">in</span> alist[i+<span class="number">1</span>:]:<span class="comment"># O(N) - index+add+slice+in: O(1)+O(1)+O(N)+O(N)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span>             <span class="comment"># O(1) - never executed in worst case</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">True</span>                  <span class="comment"># O(1)</span></span><br></pre></td></tr></table></figure>
<p>The complexity class for executing the entire function is O(N) * O(N) + O(1) = O(N^2). So we know from the previous lecture that if we double the length of alist, this function takes 4 times as long to execute.</p>
<p>Note that in the worst case, we never return False and keep executing the loop, so this O(1) does not appear in the answer. Also, in the worst case the list slice is aliset[1:] which is O(N-1) = O(N).</p>
<h4 id="Algorithm-2"><a href="#Algorithm-2" class="headerlink" title="Algorithm 2"></a>Algorithm 2</h4><blockquote>
<p>A list is unique if when we sort its values, no ADJACENT values are equal. If there were duplicate values, sorting the list would put these duplicate values right next to each other (adjacent). Here we copy the list so as to not mutate (change the order of the parameter’s list) by sorting it: it turns out that copying the list does not increase the complexity class of the method.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique2</span> <span class="params">(alist)</span>:</span></span><br><span class="line">  copy = list(alist)            <span class="comment"># O(N)</span></span><br><span class="line">  copy.sort()                   <span class="comment"># O(N Log N) - for fast Python sorting</span></span><br><span class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(len(alist)<span class="number">-1</span>): <span class="comment"># O(N) - really N-1, but that is O(N)</span></span><br><span class="line">    <span class="keyword">if</span> copy[i] == copy[i+<span class="number">1</span>]:    <span class="comment"># O(1): +, 2 [i], and  == ints: all O(1)</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">False</span>              <span class="comment"># O(1) - never executed in worst case</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">True</span>                   <span class="comment"># O(1)</span></span><br></pre></td></tr></table></figure>
<p>The complexity class for executing the entire function is given by the sum O(N) + O(N Log N) + O(N)*O(1) + O(1) = O(N + N Log N + O(N*1) + 1) = O(N + N Log N + N + 1) = O(N Log N + 2N + 1) = O(N Log N). So the complexity class for this algorithm/function is lower than the first algorithm, the <code>is_unique1</code> function. For large N <code>is_unique2</code> will eventually be faster.</p>
<p>Notice that the complexity class for sorting is dominant in this code: it does most of the work. If we double the length of alist, this function takes a bit more than twice the amount of time. In N Log N: N doubles and Log N gets a tiny bit bigger (i.e., Log 2N = 1 + Log N; e.g., Log 2000 = 1 + Log 1000 = 11, so compared to 1000 Log 1000, 2000 Log 2000 got 2.2 times bigger, or 10% bigger than just doubling).</p>
<p>Looked at another way if<br>$T(N) = c*(N Log N)$</p>
<p>then,<br>$T(2N) = c*(2N Log 2N)$ = $c*2N*(Log N + 1)$ = $c*2N Log N + c*2N$ = $2*T(N) + c*2N$</p>
<p>Or, computing the doubling signature</p>
<figure class="highlight excel"><table><tr><td class="code"><pre><span class="line"><span class="built_in">T</span>(<span class="number">2</span><span class="built_in">N</span>)    c*<span class="number">2</span>(<span class="built_in">N</span> <span class="built_in">Log</span> <span class="built_in">N</span>) + c*<span class="number">2</span><span class="built_in">N</span>            <span class="number">2</span></span><br><span class="line">----- =  -------------------  =  <span class="number">2</span> + -------</span><br><span class="line"><span class="built_in">T</span>(<span class="built_in">N</span>)          c*(<span class="built_in">N</span> <span class="built_in">Log</span> <span class="built_in">N</span>)             <span class="built_in">Log</span> <span class="built_in">N</span></span><br></pre></td></tr></table></figure>
<p>So, the ratio is 2 + a bit (and that bit gets smaller as N increases)</p>
<h4 id="Algorithm-3"><a href="#Algorithm-3" class="headerlink" title="Algorithm 3"></a>Algorithm 3</h4><blockquote>
<p>A list is unique if when we turn it into a set, its length is unchanged: if duplicate values were added to the set, its length would be smaller than the length of the list by exactly the number of duplicates in the list added to the set.</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">is_unique3</span> <span class="params">(alist)</span>:</span></span><br><span class="line">    aset = set(alist)              <span class="comment"># O(N): construct set from alist values</span></span><br><span class="line">    <span class="keyword">return</span> len(aset) == len(alist) <span class="comment"># O(1): 2 len (each O(1)) and == ints O(1)</span></span><br></pre></td></tr></table></figure>
<p>The complexity class for executing the entire function is O(N) + O(1) = O(N + 1) = O(N). So the complexity class for this algortihm/function is lower than both the first and second algorithms/functions. If we double the length of alist, this function takes just twice the amount of time. We could write the body of this function more simply as:<br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> len(set(alist)) == len(alist)</span><br></pre></td></tr></table></figure></p>
<p>where evaluating set(alist) takes O(N) and then computing the two len’s and comparing them for equality are all O(1).</p>
<p>So the bottom line here is that there might be many algorithms/functions to solve some problem. If they are small, we can analyze them statically (looking at the code, not running it) to determine their complexity classes. For large problem sizes, the algorithm/function with the smallest complexity class will be best. For small problem sizes, complexity classes don’t determine which is best (we need to account for the constants and lower order terms when sizes are small), but we could run the functions (dynamic analysis, aka empirical analysis) to test which is fastest on small size.</p>
<hr>
<h3 id="Priority-Queue"><a href="#Priority-Queue" class="headerlink" title="Priority Queue"></a>Priority Queue</h3><p>Using a Class (implementable 3 ways) Example:</p>
<p>We will now look at the solution of a few problems (combining operations on a <code>priority queue</code>: <code>pq</code>) and how the complexity class of the result is affected by three different classes/implementations of priority queues.</p>
<p>In a priority queue, we can add values and remove values to the data structure. A correctly working priority queue always removes the maximum value remaining in the priority queue. Think of a line/queue outside of a Hollywood nightclub, such that whenever space opens up inside, the most famous person in line gets to go in (the “highest priority” person), no matter how long less famous people have been standing in line (contrast this with <code>first come/first serve</code>, which is a regular -non priority- queue).</p>
<p>For the problems below, all we need to know is the complexity class of the “add” and “remove” operations.</p>
<table>
<thead>
<tr>
<th></th>
<th>add</th>
<th>remove</th>
</tr>
</thead>
<tbody>
<tr>
<td>Implementation 1</td>
<td><code>O(1)</code></td>
<td><code>O(N)</code></td>
</tr>
<tr>
<td>Implementation 2</td>
<td><code>O(N)</code></td>
<td><code>O(1)</code></td>
</tr>
<tr>
<td>Implementation 3</td>
<td><code>O(Log N)</code></td>
<td><code>O(Log N)</code></td>
</tr>
</tbody>
</table>
<p><strong>Implementation 1</strong> adds the new value into the pq by appending the value at the rear of a list or the front of a linked list: both are O(1); it removes the highest priority value by scanning through the list or linked list to find the highest value, which is O(N), and then removing that value, also O(N) in the worst case  (removing at the front of a list; at the rear of a linked list).</p>
<p><strong>Implementation 2</strong> adds the new value into the pq by scanning the list or linked list for the right spot to put it and putting it there, which is O(N). Lists store their highest priority at the rear (linked lists at the front); it removes the highest priority value from the rear for lists (or the front for linked lists), which is O(1).</p>
<p><strong>Implementation 3</strong>, which is discussed in <a href="http://www.ics.uci.edu/~thornton/ics46/Notes/PriorityQueues/" target="_blank" rel="noopener">ICS-46</a>, uses a binary heap tree (not a binary search tree) to implement both operations with “middle” complexity O(Log N): this complexity class greater than O(1) but less than O(N).</p>
<h4 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem 1"></a>Problem 1</h4><blockquote>
<p>Suppose we wanted to use the priority queue to sort N values: we add N values in the pq and then remove all N values (first the highest, next the second highest, …). Here is the complexity of these combined operations for each implementation.</p>
</blockquote>
<ul>
<li>Implementation 1:<br>$O(N)*O(1) + O(N)*O(N)$         = $O(N)   + O(N^2)$    = $O(N^2)$</li>
<li>Implementation 2:<br>$O(N)*O(N) + O(N)*O(1)$         = $O(N^2) + O(N)$      = $O(N^2)$</li>
<li>Implementation 3:<br>$O(N)*O(Log N) + O(N)*O(Log N)$ = $O(N LogN) + O(N LogN)$ = $O(N LogN)$</li>
</ul>
<p>Here, Implementation 3 has the lowest complexity class for the combined operations. Implementations 1 and 2 each do one operation quickly but the other slowly: both are done O(N) times. The slowest operation determines the complexity class, and both are equally slow. The complexity class O(Log N) is between O(1) and O(N); surprisingly, it is actually “closer” to O(1) than O(N), even though it does grow -because it grows so slowly; yes, O(1) doesn’t grow at all, but O(Log N) grows very slowly: the known Universe has about $ 10^{90} $ particles of matter, and $ Log_2(10^{90}) = Log_2 (10 ^ 3) ^ {30} \approx 30 * 10 = 300 $, which isn’t very big compared to $10^{90}$.</p>
<h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem 2"></a>Problem 2</h4><blockquote>
<p>Suppose we wanted to use the priority queue to find the 10 biggest (of N) values: we would enqueue N values and then dequeue 10 values. Here is the complexity of these combined operations for each implementation..</p>
</blockquote>
<ul>
<li>Implementation 1:<br>$O(N)*O(1) + O(10)*O(N)$        = $O(N)   + O(N)$      = $O(N)$</li>
<li>Implementation 2:<br>$O(N)*O(N) + O(10)*O(1)$         = $O(N^2) + O(1)$     = $O(N^2)$</li>
<li>Implementation 3:<br>$O(N)*O(Log N) + O(10)*O(Log N)$ = $O(N LogN) + O(LogN)$ = $O(N LogN)$</li>
</ul>
<p>Here, Implementation 1 has the lowest complexity for the combined operations. That makes sense, as the operation done O(N) times (add) is very simple (add to the end of a list/the front of a linked list is O(1)) and the operation done a constant number of times (10, independent of N) is the expensive operation (remove, which is O(N)). It even beats the complexity of Implementation 3. So, as N gets bigger, implementation 1 will eventually become faster than the other two for the “find the 10 biggest” task.</p>
<blockquote>
<p><strong>Kai’s comment</strong>:</p>
<p>For problem 2, the author came to a conclusion that, the brutal loop through the $N$ values for $K$ times, performs better than a heap based solution. It violates my intuition.<br>The questionable part is the cost of building a heap: $O(N LogN)$. The cost of <code>heapsort</code> is the same, and by heapsorting an array, all the elements are sorted. Then why should we perform an operation, that is close to heapsort, to find top $K$ elements?<br>I will discuss this in another blog <a href="/posts/solve-biggest-k-problem-by-heap-in-right-way/">Solve Biggest K Problem By Heap, In Right Way</a></p>
</blockquote>
<p>So, the bottom line here is that sometimes there is NOT a “best all the time” implementation for a data structure. We need to know what problem we are solving (the complexity classes of all the operations in various implementations and the number of times we must do these operations) to choose the most efficient implementation for solving the problem.</p>
</div><div class="post-meta"><div class="tags"><a href="/tags/python/">python</a><a href="/tags/complexity/">complexity</a><!-- tag.name--></div></div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><div><a data-url="http://westworld.name/posts/complexity-of-python-operations/" data-id="cjkq38c1q001k5iqbljk3prcl" class="article-share-link">Share</a></div><div id="disqus_show" class="readmore"><a class="show-comments" href="javascript:return false;"><span class="disqus-comment-count" data-disqus-identifier="posts/complexity-of-python-operations/"> Comments</span></a></div><div id="disqus_thread"></div><script>// Requires jQuery of course.
$(document).ready(function() {
    $('.show-comments').on('click', function(){
        var disqus_shortname = 'kaigithub';
        // ajax request to load the disqus javascript
        $.ajax({
                type: "GET",
                url: "//" + disqus_shortname + ".disqus.com/embed.js",
                dataType: "script",
                cache: true
        });
        // hide the button once comments load
        $(this).fadeOut();
    });
});
</script><script id="dsq-count-scr" src="//kaigithub.disqus.com/count.js" async></script><div id="post_nav_container" class="screen-wide-bg">  <div class="post-nav pure-u-1 pure-u-md-4-4"><div class="pure-u-md-1-2"><a href="/posts/blog-new-logo/" class="pre"><span>Blog New Logo</span><i><img src="/images/blog-logo.png" class="nofancybox"></i></a></div><div class="pure-u-md-1-2"> <a href="/posts/on-priority-queue/" class="next"><span>On Priority Queue</span><i><img src="/images/food/cherries.png" class="nofancybox"/></i></a></div></div></div></div></div></div><div class="pure-u-1 pure-u-md-4-4"><div id="footer"><p>© <a href="/." rel="nofollow">Westworld.</a><span> Site Generated by <a rel="nofollow" target="_blank" href="https://hexo.io">Hexo. </a></span></p><p> <span> Theme modified from <a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo">Maupassant. </a></span><span>Icons from <a rel="nofollow" target="_blank" href="http://www.flaticon.com">Flaticon </a>are licensed by CC 3.0 BY.</span></p></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/x-mathjax-config">MathJax.Hub.Config({
  messageStyle: "none",
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    preview: "none"
  }
});
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></body></html>